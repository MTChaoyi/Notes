# POJO

- Plain Old Java Object（简单的、普通Java对象）
- 主要用来指代那些没有遵从特定的 Java 对象模型、约定或框架（如EJB）的 Java 对象
- 不具有任何特殊角色，不继承或不实现任何其它 Java 框架的类或接口
- 可以包含类似与 JavaBean 属性和对属性访问的 setter 和 getter 方法
- 理想地讲，一个 POJO 是一个不受任何限制的 Java 对象（除了Java语言规范）

# JavaBean

- 一种特殊的 Java 类，它通常用来实现一些比较常用的简单功能，并可以很容易的被重用或者是插入其他应用程序中去
- 所有遵循“一定编程原则”的Java类都可以被称作 JavaBean
- 它的方法命名，构造及行为必须符合特定的约定：
  1. 这个类必须具有一个公共的（public）无参构造函数；
  2. 所有属性私有化（private）；
  3. 私有化的属性必须通过 public 类型的方法（getter和setter）暴露给其他程序，并且方法的命名也必须遵循一定的命名规范。 
  4. 这个类应是可序列化的。（比如可以实现Serializable 接口，用于实现bean的持久性）

# RDBMS

- Relational Database Management System（关系型数据库管理系统）
- 是 SQL 语言以及所有现代数据库系统（例如 SQL Server、DB2、Oracle、MySQL 和 Microsoft Access）的基础
- 是一种基于 E. F. Codd 发明的关系模型的数据库管理系统（DBMS）

# Impl

- implement（实现）
- xxxxImpl.java 为接口 xxxx.java 的实现类
- 在 Java 开发中，通常将后台分成几层，常见的是三层 mvc：model、view、controller，模型视图控制层三层，而 impl 通常处于 controller 层的 service 下，用来存放接口的实现类

# Dao

- 数据持久化层
- 负责与数据库进行联络的一些任务都封装在此
- dao层的设计首先是设计dao层的接口，然后在Spring的配置文件中定义此接口的实现类，然后就可以再模块中调用此接口来进行数据业务的处理，而不用关心此接口的具体实现类是哪个类，显得结构非常清晰

# ORM

- Object Relational Mapping（对象关系映射）
- 其主要作用是在编程中，把面向对象的概念跟数据库中表的概念对应起来。举例来说就是，我定义一个对象，那就对应着一张表，这个对象的实例，就对应着表中的一条记录
- 用 ORM 的好处就是你不用操作表，可以在程序中用面向对象的思路，直接操作对象即可
- 常见的 ORM 框架有 `Hibernate` `iBATIS` `mybatis` `eclipseLink` `JFinal` 
- 优点：
  - 提高开发效率，降低开发成本
  - 使开发更加对象化
  - 可移植
  - 可以很方便地引入数据缓存之类的附加功能
- 缺点：
  - 自动化进行关系数据库的映射需要消耗系统性能（一般来说可以忽略）
  - 在处理多表联查、where 条件复杂之类的查询时，ORM 的语法会变得复杂

# Service

- 业务层
- 所有的内部的业务逻辑都会放在这里处理，比如用户的增删改查，或者发送个验证码或邮件，或者做一个抽奖活动等等
- service 层的业务，具体要调用已经定义的dao层接口，封装service层业务逻辑有利于通用的业务逻辑的独立性和重复利用性
- 如果你的业务非常简单，不需要经常变动，在保障安全的情况下，让 Controller 直接操作 Dao 也是可以的，**但这样并不符合项目架构设计原则，而且一旦项目需要变动时，真的会越改越废**
- Service 的含义本身就是服务的意思，大量的逻辑性代码会在 Service 中进行，而 Dao 只需要负责 CRUD 即可，各司其职，结构非常清晰，而一旦省去 Service 层，那么你的逻辑代码，要么在 Controller 中进行，要么在 Dao 中进行，这样会引起整个项目的混乱，而且也非常不安全，这对于项目的后期维护工作是灾难性的

# Controller

- 业务控制层
- 顾名思义，业务控制，就是控制业务层 Service 的，它的作用主要是架起了外界与业务层沟通的桥梁
- 针对具体的业务流程，会有不同的控制器。我们具体的设计过程可以将流程进行抽象归纳，设计出可以重复利用的子单元流程模块。这样不仅使程序结构变得清晰，也大大减少了代码量
